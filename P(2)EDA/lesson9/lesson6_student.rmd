Lesson 6
========================================================

### Welcome
Notes: Diamonds INd

***

### Scatterplot Review
Let's start by examining two variables in the data set. The scatterplot is a powerful tool to help you understand the relationship between two continuous variables. We can quickly see if the relationship is linear or not. In this case, we can use a variety of diamond characteristics to help us figure out whether the price advertised for any given diamond is reasonable or a rip-off.
```{r Scatterplot Review}
names(diamonds)

ggplot(aes(carat,price), data= diamonds) + 
  xlim(0, quantile(diamonds$carat, .99)) +
  ylim(0, quantile(diamonds$price, .99)) + 
geom_point(fill=I("#fc8d59"), color= I('black'), shape =21)


```

***

### Price and Carat Relationship
Response: We can see that the disportion of carat size increases, the price of the diamonds also increases. We can see a non linear relationship, maybe its exponential.

```{r}
ggplot(aes(carat,price), data= diamonds) + 
  geom_point(color="#fc8d59",alpha = 1/4)+
  stat_smooth(method="lm")+
  xlim(0, quantile(diamonds$carat, .99)) +
  ylim(0, quantile(diamonds$price, .99))

```
***

### Frances Gerety
Notes:

#### A diamonds is forever.


***

### The Rise of Diamonds
Notes: Two month salary, 

***

### ggpairs Function
Notes:

```{r ggpairs Function}
# install these if necessary
install.packages('GGally')
install.packages('scales')
install.packages('memisc')
install.packages('lattice')
install.packages('MASS')
install.packages('car')
install.packages('reshape')
install.packages('plyr')

# load the ggplot graphics package and the others
library(ggplot2)
library(GGally)
library(scales)
library(memisc)

# sample 10,000 diamonds from the data set
set.seed(20022012)
diamond_samp <- diamonds[sample(1:length(diamonds$price), 10000), ]
ggpairs(diamond_samp, 
        lower = list(continuous = wrap("points", shape = I('.'))), 
        upper = list(combo = wrap("box", outlier.shape = I('.'))))
```

What are some things you notice in the ggpairs output?
Response:
The matrix plot gives us great insights about each variable against each other. This goes back towards the previous lesson of creating volume from variables x, y, z against price. As it appears in the plot, combining multiple variables would allow our answers to be more finite. The variables, cut, color, and clarity they are all boxplots, which can give us some directions that those variables may have the same relationships or reaction in the matrix design. 
***

### The Demand of Diamonds
Noes: 

```{r The Demand of Diamonds}

library(gridExtra)

plot1 <- ggplot(aes(price),data=diamonds) + 
  geom_histogram(binwidth = 100)+
  ggtitle('Price')

plot2 <- ggplot(aes(price),data=diamonds) + 
  geom_histogram(binwidth = .01)+
  scale_x_log10()+
  ggtitle('Price (log10)')

grid.arrange(plot1,plot2)

```

***

### Connecting Demand and Price Distributions
Notes: The first plot is long-tailed and more right-skewed distribution, and by log-transforming from the original plot, it gives us a more variance within the price range of symmetric distribution. 

***

### Scatterplot Transformation

```{r Scatterplot Transformation}

ggplot(aes(carat,price),data= diamonds) + geom_point()+
  scale_y_continuous(trans= log10_trans()) + 
  ggtitle('Price (log10) by Carat')

```


### Create a new function to transform the carat variable

```{r cuberoot transformation}
cuberoot_trans = function() trans_new('cuberoot', transform = function(x) x^(1/3),
                                      inverse = function(x) x^3)
```
Note: In case you want to learn about creating your own function. check this link: https://www.youtube.com/watch?v=Z1wB1rHAYzQ&list=PLOU2XLYxmsIK9qQfztXeybpHvru-TrqAP&index=16



#### Use the cuberoot_trans function
```{r Use cuberoot_trans}
ggplot(aes(carat, price), data = diamonds) + 
  geom_point() + 
  scale_x_continuous(trans = cuberoot_trans(), limits = c(0.2, 3),
                     breaks = c(0.2, 0.5, 1, 2, 3)) + 
  scale_y_continuous(trans = log10_trans(), limits = c(350, 15000),
                     breaks = c(350, 1000, 5000, 10000, 15000)) +
  ggtitle('Price (log10) by Cube-Root of Carat')
```

Now we can identify our plot to be more linear. 
***

### Overplotting Revisited

```{r Sort and Head Tables}
head(sort(table(diamonds$carat),decreasing =T))
head(sort(table(diamonds$price),decreasing =T))

```
As identified these are really high number so they are overplotting.

```{r Overplotting Revisited}

ggplot(aes(carat, price), data = diamonds) + 
  geom_point(alpha=.5, size=3/4,position= 'jitter') + 
  scale_x_continuous(trans = cuberoot_trans(), limits = c(0.2, 3),
                     breaks = c(0.2, 0.5, 1, 2, 3)) + 
  scale_y_continuous(trans = log10_trans(), limits = c(350, 15000),
                     breaks = c(350, 1000, 5000, 10000, 15000)) +
  ggtitle('Price (log10) by Cube-Root of Carat')
```

***

### Other Qualitative Factors
Notes: clarity seems to factor into price, but it depends on the 

***

### Price vs. Carat and Clarity

Alter the code below.
```{r Price vs. Carat and Clarity}
# install and load the RColorBrewer package
install.packages('RColorBrewer')
library(RColorBrewer)

? diamonds()

ggplot(aes(x = carat, y = price), data = diamonds) + 
  geom_point(aes(color= clarity),alpha = 0.5, size = 1, position = 'jitter') +
  scale_color_brewer(type = 'div',
    guide = guide_legend(title = 'Clarity', reverse = T,
    override.aes = list(alpha = 1, size = 2))) +  
  scale_x_continuous(trans = cuberoot_trans(), limits = c(0.2, 3),
    breaks = c(0.2, 0.5, 1, 2, 3)) + 
  scale_y_continuous(trans = log10_trans(), limits = c(350, 15000),
    breaks = c(350, 1000, 5000, 10000, 15000)) +
  ggtitle('Price (log10) by Cube-Root of Carat and Clarity')
```

***

### Clarity and Price
Response:
You can notice that clarity does have a factor when it comes to price. For instance, a diamonds with a clarity of (I1) is ranked amount the worst of the diamonds, which can be sold for a lot cheaper. Contrarily, those (IF & WS1 & WS2) with the best clarity are always sold at higher price. The color is the differentiator in our model. 

***

### Price vs. Carat and Cut

Alter the code below.
```{r Price vs. Carat and Cut}
ggplot(aes(x = carat, y = price, color = clarity), data = diamonds) + 
  geom_point(alpha = 0.5, size = 1, position = 'jitter') +
  scale_color_brewer(type = 'div',
                     guide = guide_legend(title = 'Clarity', reverse = T,
                                          override.aes = list(alpha = 1, size = 2))) +  
  scale_x_continuous(trans = cuberoot_trans(), limits = c(0.2, 3),
                     breaks = c(0.2, 0.5, 1, 2, 3)) + 
  scale_y_continuous(trans = log10_trans(), limits = c(350, 15000),
                     breaks = c(350, 1000, 5000, 10000, 15000)) +
  ggtitle('Price (log10) by Cube-Root of Carat and Clarity')
```

***

### Cut and Price
Response: 

There seems to be one color of the diamonds, that is dominantly taking over this visualization as the size of Carat is increasing. It's pertaining that cuts being done more professional are sold more frequent, besides the variances of diamonds as the carat sizes are greater. 

***

### Price vs. Carat and Color

Alter the code below.
```{r Price vs. Carat and Color}
ggplot(aes(x = carat, y = price, color = color), data = diamonds) + 
  geom_point(alpha = 0.5, size = 1, position = 'jitter') +
  scale_color_brewer(type = 'div',
                     guide = guide_legend(title = 'color',
                                          override.aes = list(alpha = 1, size = 2))) +  
  scale_x_continuous(trans = cuberoot_trans(), limits = c(0.2, 3),
                     breaks = c(0.2, 0.5, 1, 2, 3)) + 
  scale_y_continuous(trans = log10_trans(), limits = c(350, 20000),
                     breaks = c(350, 1000, 5000, 10000, 15000)) +
  ggtitle('Price (log10) by Cube-Root of Carat and Color')
```

***

### Color and Price
Response: The color of a diamonds influences that price because each color seems to have a linear and a parallel consistency with each other having a different price tag as carat increases. 

***

### Linear Models in R
Notes:

Response:

***

### Building the Linear Model
Notes:

```{r Building the Linear Model}
m1 <- lm(I(log(price)) ~ I(carat^(1/3)), data = diamonds)
m2 <- update(m1, ~ . + carat)
m3 <- update(m2, ~ . + cut)
m4 <- update(m3, ~ . + color)
m5 <- update(m4, ~ . + clarity)
mtable(m1, m2, m3, m4, m5)
```

Notice how adding cut to our model does not help explain much of the variance
in the price of diamonds. This fits with out exploration earlier.

***

### Model Problems
Video Notes:

Research:
(Take some time to come up with 2-4 problems for the model)
(You should 10-20 min on this)

Response:

***

### A Bigger, Better Data Set
Notes:

```{r A Bigger, Better Data Set}
install.packages('bitops')
install.packages('RCurl')
library('bitops')
library('RCurl')

diamondsurl = getBinaryURL("https://raw.github.com/solomonm/diamonds-data/master/BigDiamonds.Rda")
load(rawConnection(diamondsurl))


load("BigDiamonds.rda")

head(diamondsbig)
# ENTER YOUR CODE BELOW THIS LINE. (Create the five models)
#===========================================================================================

diamondsbig$logprice = log(diamondsbig$price)
m1 = lm(logprice~  I(carat^(1/3)), 
    data=diamondsbig[diamondsbig$price < 10000 & diamondsbig$cert == 'GIA',])
m2 = update(m1, ~ . + carat)
m3 = update(m2, ~ . + cut )
m4 = update(m3, ~ . + color + clarity)


# DO NOT ALTER THE CODE BELOW THIS LINE (Tables your models and pulls out the statistics)
#===========================================================================================
suppressMessages(library(lattice))
suppressMessages(library(MASS))
suppressMessages(library(memisc))
models <- mtable(m1, m2, m3, m4)



models
```

The code used to obtain the data is available here:
https://github.com/solomonm/diamonds-data

## Building a Model Using the Big Diamonds Data Set
Notes:

```{r Building a Model Using the Big Diamonds Data Set}



```


***

## Predictions

Example Diamond from BlueNile:
Round 1.00 Very Good I VS1 $5,601

```{r}
#Be sure you’ve loaded the library memisc and have m5 saved as an object in your workspace.
thisDiamond = data.frame(carat = 1.00, cut = "V.Good",
                         color = "I", clarity="VS1")
modelEstimate = predict(m4, newdata = thisDiamond,
                        interval="prediction", level = .95)

modelEstimate

exp(modelEstimate)

dat = data.frame(m4$model, m4$residuals)
with(dat, sd(m4.residuals))


with(subset(dat, carat > .9 & carat < 1.1), sd(m4.residuals))
dat$resid <- as.numeric(dat$m4.residuals)
ggplot(aes(y = resid, x = round(carat, 2)), data = dat) +
  geom_line(stat = "summary", fun.y = sd)
```

Evaluate how well the model predicts the BlueNile diamond's price. Think about the fitted point estimate as well as the 95% CI.

***

## Final Thoughts
Notes:

***

Click **KnitHTML** to see all of your hard work and to have an html
page of this lesson, your answers, and your notes!

